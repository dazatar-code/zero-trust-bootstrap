name: Tor CDP Relay - Protocol Gateway
on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action: search, navigate, scrape'
        required: true
        default: 'search'
      url:
        description: 'URL or search query'
        required: true
      selector:
        description: 'CSS selector (optional)'
        required: false
        default: ''
      wait_ms:
        description: 'Wait time in ms'
        required: false
        default: '5000'
      timeout:
        description: 'Timeout in seconds'
        required: false
        default: '90'

jobs:
  browser-task:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Install Tor and Privoxy
        run: |
          echo "üßÖ Installing Tor + Privoxy..."
          sudo apt-get update
          sudo apt-get install -y tor privoxy netcat-openbsd
          
          # STOP Privoxy (auto-starts on install with default config)
          sudo service privoxy stop || true
          
          # Start Tor FIRST
          sudo service tor start
          
          echo "‚è≥ Waiting for Tor SOCKS to be ready..."
          for i in $(seq 1 60); do
            if nc -z 127.0.0.1 9050 2>/dev/null; then
              echo "‚úÖ Tor SOCKS port 9050 is open (attempt $i)"
              break
            fi
            echo "  Waiting for Tor... ($i/60)"
            sleep 2
          done
          
          # Give Tor time to build circuits
          echo "‚è≥ Waiting 20s for Tor to establish circuits..."
          sleep 20
          
          # Configure Privoxy - use tee with multiple lines (no heredoc)
          echo "üîß Configuring Privoxy..."
          echo "confdir /etc/privoxy" | sudo tee /etc/privoxy/config > /dev/null
          echo "logdir /var/log/privoxy" | sudo tee -a /etc/privoxy/config > /dev/null
          echo "listen-address 127.0.0.1:8118" | sudo tee -a /etc/privoxy/config > /dev/null
          echo "toggle 1" | sudo tee -a /etc/privoxy/config > /dev/null
          echo "forward-socks5t / 127.0.0.1:9050 ." | sudo tee -a /etc/privoxy/config > /dev/null
          
          echo "üìã Privoxy config:"
          cat /etc/privoxy/config
          
          # Start Privoxy
          echo ""
          echo "üîß Starting Privoxy..."
          sudo service privoxy start
          sleep 3
          
          # Verify both services
          echo ""
          echo "üìä Service Status:"
          if nc -z 127.0.0.1 9050; then echo "  ‚úÖ Tor SOCKS (9050) - OK"; else echo "  ‚ùå Tor SOCKS (9050) - FAIL"; fi
          if nc -z 127.0.0.1 8118; then echo "  ‚úÖ Privoxy HTTP (8118) - OK"; else echo "  ‚ùå Privoxy HTTP (8118) - FAIL"; fi
          
          # Test chain
          echo ""
          echo "üîç Testing Privoxy -> Tor -> Internet..."
          TEST_RESULT=$(curl -s --proxy http://127.0.0.1:8118 --max-time 30 http://example.com 2>&1 || echo "CURL_FAILED")
          if echo "$TEST_RESULT" | grep -q "Example Domain"; then
            echo "‚úÖ Gateway chain working!"
          else
            echo "‚ö†Ô∏è Gateway test result:"
            echo "$TEST_RESULT" | head -5
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Puppeteer
        run: |
          npm init -y
          npm install puppeteer
          echo "‚úÖ Puppeteer installed"

      - name: Execute Browser Task
        env:
          ACTION: ${{ github.event.inputs.action }}
          TARGET_URL: ${{ github.event.inputs.url }}
          SELECTOR: ${{ github.event.inputs.selector }}
          WAIT_MS: ${{ github.event.inputs.wait_ms }}
          TIMEOUT: ${{ github.event.inputs.timeout }}
        run: |
          echo "üåê Browser Task"
          echo "   Action: $ACTION"
          echo "   URL/Query: $TARGET_URL"
          echo ""
          
          node << 'NODEEOF'
          const puppeteer = require('puppeteer');
          
          const AHMIA_URL = 'http://juhanurmihxlp77nkq76byazcldy2hlmovfu2epvl5ankdibsot4csyd.onion';
          
          async function run() {
            const action = process.env.ACTION;
            const targetUrl = process.env.TARGET_URL;
            const selector = process.env.SELECTOR || '';
            const waitMs = parseInt(process.env.WAIT_MS) || 5000;
            const timeoutMs = parseInt(process.env.TIMEOUT) * 1000 || 90000;
            
            console.log('üöÄ Launching browser...');
            console.log('   Chain: Chrome -> Privoxy (8118) -> Tor (9050) -> .onion');
            console.log('');
            
            const browser = await puppeteer.launch({
              headless: 'new',
              args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--proxy-server=http://127.0.0.1:8118',
                '--disable-extensions',
                '--disable-background-networking',
                '--disable-sync',
                '--disable-default-apps',
                '--no-first-run',
                // Enable .onion URL access
                '--disable-features=BlockInsecurePrivateNetworkRequests',
                '--allow-running-insecure-content',
                '--disable-web-security',
                '--ignore-certificate-errors',
                // Force proxy for all URLs including .onion
                '--proxy-bypass-list=<-loopback>',
                '--host-resolver-rules=MAP * ~NOTFOUND , EXCLUDE 127.0.0.1'
              ]
            });
            
            const page = await browser.newPage();
            await page.setViewport({ width: 1920, height: 1080 });
            await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; rv:109.0) Gecko/20100101 Firefox/115.0');
            page.setDefaultNavigationTimeout(timeoutMs);
            
            let result = {
              action: action,
              success: false,
              timestamp: new Date().toISOString()
            };
            
            try {
              if (action === 'search') {
                console.log(`üîç Searching Ahmia for: "${targetUrl}"`);
                
                await page.goto(AHMIA_URL, { waitUntil: 'networkidle2', timeout: timeoutMs });
                console.log('   ‚úÖ Ahmia homepage loaded');
                
                await page.waitForSelector('input[name="q"]', { timeout: 15000 });
                await page.type('input[name="q"]', targetUrl);
                console.log('   ‚úÖ Query entered');
                
                await Promise.all([
                  page.waitForNavigation({ waitUntil: 'networkidle2', timeout: timeoutMs }),
                  page.click('input[type="submit"]')
                ]);
                console.log('   ‚úÖ Search submitted');
                
                await new Promise(r => setTimeout(r, waitMs));
                console.log(`   ‚úÖ Waited ${waitMs}ms for JS`);
                
                result.searchResults = await page.evaluate(() => {
                  const results = [];
                  const selectors = ['li.result', '.result', '.search-result', 'li[class*="result"]'];
                  
                  let items = [];
                  for (const sel of selectors) {
                    items = document.querySelectorAll(sel);
                    if (items.length > 0) break;
                  }
                  
                  items.forEach((item, i) => {
                    if (i >= 15) return;
                    const link = item.querySelector('a[href*=".onion"]') || item.querySelector('a');
                    const title = item.querySelector('h4, h3, .title, a');
                    const snippet = item.querySelector('p, .snippet, .description');
                    
                    if (link && link.href) {
                      results.push({
                        title: title ? title.textContent.trim().substring(0, 100) : 'No title',
                        url: link.href,
                        snippet: snippet ? snippet.textContent.trim().substring(0, 200) : ''
                      });
                    }
                  });
                  
                  if (results.length === 0) {
                    document.querySelectorAll('a[href*=".onion"]').forEach((link, i) => {
                      if (i >= 15) return;
                      results.push({
                        title: link.textContent.trim().substring(0, 100) || 'Link',
                        url: link.href,
                        snippet: ''
                      });
                    });
                  }
                  
                  return results;
                });
                
                result.resultsCount = result.searchResults.length;
                result.success = true;
                console.log(`   ‚úÖ Extracted ${result.resultsCount} results`);
                
              } else if (action === 'navigate' || action === 'scrape') {
                console.log(`üåê Navigating to: ${targetUrl}`);
                
                await page.goto(targetUrl, { waitUntil: 'networkidle2', timeout: timeoutMs });
                await new Promise(r => setTimeout(r, waitMs));
                
                result.url = page.url();
                result.title = await page.title();
                
                if (selector) {
                  try {
                    result.content = await page.$eval(selector, el => el.innerHTML);
                  } catch (e) {
                    result.content = await page.content();
                  }
                } else {
                  result.content = await page.content();
                }
                
                result.onionLinks = await page.evaluate(() => {
                  return Array.from(document.querySelectorAll('a[href*=".onion"]'))
                    .map(a => a.href)
                    .filter((v, i, a) => a.indexOf(v) === i)
                    .slice(0, 20);
                });
                
                result.success = true;
                console.log(`   ‚úÖ Page loaded: ${result.title}`);
              }
              
            } catch (error) {
              result.error = error.message;
              result.stack = error.stack;
              console.error(`‚ùå Error: ${error.message}`);
            }
            
            await browser.close();
            
            console.log('');
            console.log('======== RESULT START ========');
            console.log(JSON.stringify(result, null, 2));
            console.log('======== RESULT END ========');
          }
          
          run().catch(err => {
            console.error('Fatal:', err);
            console.log('======== RESULT START ========');
            console.log(JSON.stringify({ success: false, error: err.message }));
            console.log('======== RESULT END ========');
            process.exit(1);
          });
          NODEEOF
