name: Tor CDP Relay (Playwright)
on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action: search, navigate, scrape, screenshot'
        required: true
        default: 'search'
      url:
        description: 'URL or search query'
        required: true
        default: 'security'
      selector:
        description: 'CSS selector (for scrape action)'
        required: false
        default: ''
      wait_ms:
        description: 'Wait time after load (ms)'
        required: false
        default: '5000'
      timeout:
        description: 'Request timeout (seconds)'
        required: false
        default: '90'

jobs:
  browser-task:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Install Tor
        run: |
          echo "üßÖ Installing Tor..."
          sudo apt-get update
          sudo apt-get install -y tor
          echo "‚úÖ Tor installed"
          
      - name: Start Tor and Wait
        run: |
          echo "üöÄ Starting Tor..."
          sudo service tor start
          
          echo "‚è≥ Waiting for Tor bootstrap (up to 90s)..."
          for i in {1..30}; do
            if curl -s --socks5-hostname 127.0.0.1:9050 --max-time 5 http://check.torproject.org/api/ip 2>/dev/null | grep -q "IsTor"; then
              echo "‚úÖ Tor is ready!"
              curl -s --socks5-hostname 127.0.0.1:9050 http://check.torproject.org/api/ip
              exit 0
            fi
            echo "  Waiting... ($i/30)"
            sleep 3
          done
          echo "‚ö†Ô∏è Tor check timed out, continuing anyway..."

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm install playwright
          npx playwright install chromium --with-deps
          echo "‚úÖ Playwright + Chromium installed"

      - name: Execute Browser Task
        env:
          ACTION: ${{ github.event.inputs.action }}
          TARGET_URL: ${{ github.event.inputs.url }}
          SELECTOR: ${{ github.event.inputs.selector }}
          WAIT_MS: ${{ github.event.inputs.wait_ms }}
          TIMEOUT: ${{ github.event.inputs.timeout }}
        run: |
          echo "üåê Browser Task: $ACTION"
          echo "   Target: $TARGET_URL"
          echo ""
          
          node << 'NODEEOF'
          const { chromium } = require('playwright');
          
          const AHMIA_URL = 'http://juhanurmihxlp77nkq76byazcldy2hlmovfu2epvl5ankdibsot4csyd.onion';
          
          async function run() {
            const action = process.env.ACTION;
            const targetUrl = process.env.TARGET_URL;
            const selector = process.env.SELECTOR || '';
            const waitMs = parseInt(process.env.WAIT_MS) || 5000;
            const timeoutSec = parseInt(process.env.TIMEOUT) || 90;
            
            console.log('üöÄ Launching Playwright with Tor proxy...');
            
            const browser = await chromium.launch({
              proxy: {
                server: 'socks5://127.0.0.1:9050'
              }
            });
            
            const context = await browser.newContext({
              userAgent: 'Mozilla/5.0 (Windows NT 10.0; rv:109.0) Gecko/20100101 Firefox/115.0'
            });
            
            const page = await context.newPage();
            page.setDefaultTimeout(timeoutSec * 1000);
            
            let result = {
              action: action,
              success: false,
              timestamp: new Date().toISOString()
            };
            
            try {
              if (action === 'search') {
                console.log(`üîç Searching Ahmia for: ${targetUrl}`);
                
                await page.goto(AHMIA_URL, { waitUntil: 'networkidle', timeout: timeoutSec * 1000 });
                console.log('   ‚úÖ Ahmia loaded');
                
                await page.fill('input[name="q"]', targetUrl);
                await page.click('button[type="submit"], input[type="submit"]');
                console.log('   ‚úÖ Search submitted');
                
                await page.waitForLoadState('networkidle');
                await page.waitForTimeout(waitMs);
                console.log('   ‚úÖ Results loaded');
                
                const results = await page.evaluate(() => {
                  const items = [];
                  const selectors = ['.result', '.search-result', 'li.result', '.result-item', 'article'];
                  
                  for (const sel of selectors) {
                    document.querySelectorAll(sel).forEach(el => {
                      const link = el.querySelector('a');
                      const title = el.querySelector('h3, h4, .title, a')?.textContent?.trim();
                      const snippet = el.querySelector('p, .snippet, .description')?.textContent?.trim();
                      if (link && title) {
                        items.push({ title, url: link.href, snippet: snippet || '' });
                      }
                    });
                    if (items.length > 0) break;
                  }
                  
                  if (items.length === 0) {
                    document.querySelectorAll('a[href*=".onion"]').forEach(a => {
                      items.push({ title: a.textContent?.trim() || a.href, url: a.href, snippet: '' });
                    });
                  }
                  
                  return items.slice(0, 20);
                });
                
                result.success = true;
                result.query = targetUrl;
                result.searchResults = results;
                result.resultCount = results.length;
                console.log(`   ‚úÖ Found ${results.length} results`);
                
              } else if (action === 'navigate') {
                console.log(`üåê Navigating to: ${targetUrl}`);
                await page.goto(targetUrl, { waitUntil: 'networkidle', timeout: timeoutSec * 1000 });
                await page.waitForTimeout(waitMs);
                
                const pageInfo = await page.evaluate(() => ({
                  title: document.title,
                  url: window.location.href,
                  onionLinks: Array.from(document.querySelectorAll('a[href*=".onion"]'))
                    .map(a => ({ text: a.textContent?.trim(), href: a.href }))
                    .slice(0, 20)
                }));
                
                result.success = true;
                result.pageInfo = pageInfo;
                
              } else if (action === 'scrape') {
                console.log(`üìÑ Scraping: ${targetUrl}`);
                await page.goto(targetUrl, { waitUntil: 'networkidle', timeout: timeoutSec * 1000 });
                await page.waitForTimeout(waitMs);
                
                if (selector) {
                  const content = await page.$eval(selector, el => el.innerHTML).catch(() => null);
                  result.content = content;
                  result.success = !!content;
                } else {
                  result.content = await page.content();
                  result.text = await page.evaluate(() => document.body.innerText);
                  result.success = true;
                }
                
              } else if (action === 'screenshot') {
                console.log(`üì∏ Screenshot: ${targetUrl}`);
                await page.goto(targetUrl, { waitUntil: 'networkidle', timeout: timeoutSec * 1000 });
                await page.waitForTimeout(waitMs);
                
                const buffer = await page.screenshot({ fullPage: false });
                result.screenshot = `data:image/png;base64,${buffer.toString('base64')}`;
                result.success = true;
              }
              
            } catch (error) {
              result.error = error.message;
              console.error(`‚ùå Error: ${error.message}`);
            }
            
            await browser.close();
            
            console.log('');
            console.log('======== RESULT START ========');
            console.log(JSON.stringify(result, null, 2));
            console.log('======== RESULT END ========');
            
            process.exit(result.success ? 0 : 1);
          }
          
          run().catch(err => {
            console.error('Fatal:', err.message);
            console.log('======== RESULT START ========');
            console.log(JSON.stringify({ success: false, error: err.message }));
            console.log('======== RESULT END ========');
            process.exit(1);
          });
          NODEEOF
